## 타겟 넘버
https://school.programmers.co.kr/learn/courses/30/lessons/43165

## 전략
### DFS 계열
#### 전략 1: 재귀를 사용하는 일반적인 DFS
- 노드 하나에 대해 엣지가 2개 (+/-)인 그래프를 단방향 그래프로 바꿔서 생각해보기
- 다음 노드로의 엣지 2개는 각각 가중치가 현재 수, 현재 수에 음의 부호를 붙인 것과 같음
- DFS로 마지막 노드까지 가서, 지금까지 선택한 엣지의 가중치를 합하여 타겟 넘버가 나오는지 확인
- 시간 복잡도는 ${O(2^N)}$
    - numbers의 최대 원소 개수가 20개라는 점을 고려하면,
    - ${2^{10}}$이 1024이고 ${2^{20} = 2^{10} \times 2^{10} = 1024 \times 1024}$이기 때문에,
    - 시간 초과의 위험은 크지 않음
- 📝 코드 개선: answer를 전역 변수로 사용하는 대신, 재귀 함수가 1 또는 0을 반환하게 해서 반환값을 합하는 방법이 있음

#### 전략 2: solution을 재귀 호출 (🗒️)
- 전략 1과 동일하게 재귀를 사용하는 DFS 방식이지만,
- DFS를 위한 함수를 따로 만들지 않고 원본 리스트의 시작 지점을 1씩 증가시키며 슬라이싱하는 전략
- 리스트가 비어 있으면 숫자의 합을 확인해서 1 또는 0을 반환하고, 반환값을 합하는 방법

#### 전략 3: 재귀 없는 DFS (🗒️)
- 추후 작성 예정

### 전수 조사 계열
#### 전략 4: product (🗒️)
- `itertools.product` 함수는 iterable들을 받아서 카티시안 곱을 반환함
- 각 원소가 `(음수, 양수)` 튜플인 리스트를 이용해서 `product`를 진행
- 카티시안 곱의 각 원소(원소 n개 튜플)에 대해 sum을 적용하고, target이 되는 경우가 몇 번인지 카운트


#### 전략 5: combinations (🗒️)
- `itertools.combinations` 함수는 길이가 r인 중복 없는 조합을 반환함
- 모든 수를 양수로 더한 상태에서 어떤 수들을 음수로 바꾸면 target이 되는가를 살펴보는 전략
- 양수를 음수로 바꾸므로, 원래 합에서 어떤 수를 2번 빼야 하는 점에 유의

## 전략 6: 비트마스킹 (🗒️)
- 주어진 수들에 대해 각 수의 부호 정보를 비트로 나열하는 방식
    - 양수면 0, 음수면 1로 표시
- 가능한 모든 부호 조합을 순회하면서,
    - 각 자리의 비트를 조사하여
        - 0이면 임시 리스트에 양수 추가
        - 1이면 임시 리스트에 음수 추가
    - 임시 리스트의 sum 결과가 target이면 카운트를 1 더함
- ⚠️ 이 전략은 시간 복잡도가 ${O(2^N \cdot N)}$이라서 다른 전략에 비해 실행 시간이 긺
    - 다만, 이 문제의 입력 데이터 크기가 크지 않기에 시간 초과는 나지 않음

### 미분류
## 전략 7: DP
- 추후 계열 분류 및 전략 작성 예정