## 가장 큰 수 (❌)
https://school.programmers.co.kr/learn/courses/30/lessons/42746

## 전략 1: 인접 원소 비교 (🗒️)
- **인접한 원소 A, B를 비교**하여 두 원소를 문자열로 순서를 바꿔가며 합쳐봄
- 합친 결과, 사전상 더 큰쪽에 맞추어 원소의 순서를 정함
    - 오름차순 기준에서
        - A + B가 더 크다면 -> B, A 순
        - B + A가 더 크다면 -> A, B 순
- 파이썬에서 인접 두 원소 비교에 `functools.cmp_to_key`를 사용할 수 있음
    - 인접 원소 2개를 인자로 취하는 callable을 받는 함수
    - 이 함수의 반환 결과로 나온 callable을 정렬 함수에서 key 인자로 주면 됨
- ⚠️ 0으로만 이루어진 배열이 입력되는 케이스를 유의

## 전략 2: 문자열 반복 (🗒️)
- A + B ${\gt}$ B + A라면, AAAAA... ${\gt}$ BBBBB... 라는 아이디어
- key를 각 원소를 문자열로 바꾸어 3회 반복시킨 결과로 설정함
    - 3회 반복하는 이유는 최댓값이 1000이기 때문
        - 부연 설명: 1000은 맨 앞이 1이라서 우선순위가 매우 낮음. 따라서 최소 3자리 이상으로 길이를 맞춰줌

## 시도했으나 오답이었던 풀이들
- 각 숫자의 마지막 값으로 패딩해서 4자리를 맞추고 비교하는 방법
    - 반례
        - 입력값: `[979, 97, 978, 81, 818, 817]`
        - 기댓값: `"9799797881881817"`
        - 실제값: `"9799789781881781"`
- 각 숫자의 첫번째 값으로 패딩해서 4자리를 맞추고 비교하는 방법
    - 반례
        - 입력값: `[232, 23]`
        - 기댓값: `"23232"`
        - 실제값: `"23223"`
- ⚠️ 이 풀이들이 안되는 이유: 실제로 뒤에 올 값을 제대로 반영하지 못하기 때문! (패턴이 망가짐)
    - 마지막 패딩의 경우 그 다음에 비교 대상의 첫 자리가 오는 것을 반영하지 못하고,
    - 첫번째 패딩의 경우 그 다음에 비교 대상의 첫 자리가 오는 것은 반영하지만, 그 다음 자리의 비교 결과가 실제와 달라지게 됨