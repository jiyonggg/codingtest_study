## 조이스틱 (❌)
https://school.programmers.co.kr/learn/courses/30/lessons/42860

## 전략 1: 그리디 + 완전 탐색 (🗒️)
- 상하 이동: A->목표 글자, A->Z->목표 글자 중 횟수가 더 적은 것을 선택하면 됨
- 좌우 이동
    - 유턴을 고려해야 함 ⭐⭐⭐
    - 완전 탐색으로 A가 아닌 지점(`idx`)과 그 다음으로 나타나는 A가 아닌 지점(`next_non_a_index`)을 고르고, 유턴에 대한 2가지 상황을 탐색
        - 상황 1: 오른쪽으로 가다가 `idx`에서 왼쪽 유턴 후 `next_non_a_index`까지 가는 상황
        - 상황 2: 왼쪽으로 가다가 `next_non_a_index`에서 오른쪽 유턴 후 `idx`까지 가는 상황

## 전략 2: DFS (🗒️, 🤖)
- 0번 인덱스를 제외하고 A가 아닌 인덱스들의 배열을 만듦
- 이 배열의 맨 앞이 오른쪽으로 제일 가까운 인덱스, 이 배열의 맨 뒤가 왼쪽으로 제일 가까운 인덱스
- 각각의 인덱스에 대해서 왼쪽으로 이동하는 경우와 오른쪽으로 이동하는 경우를 비교
- 각각의 인덱스를 선택하는 상황을 재귀 호출로 만들어, A가 아닌 모든 인덱스를 방문할 때까지 DFS 실행
    - 앞의 비교에서 선택한 최솟값을 현재 이동한 거리에 더하여 전달
- 다만, 최솟값을 구하고자 하므로 정답인 가능성이 없는 경우에 미리 빠져나와 효율성을 높임

## 시도했으나 실패했던 풀이
- 주어진 문자열을 5개의 구간으로 나누어 4가지의 좌우 스틱 이동법 중 최솟값 구하기
    - 구간: A만 있는 접두사 구간 | 왼쪽 구간 | A 최다 구간 | 오른쪽 구간 | A만 있는 접미사 구간
    - 4가지의 경우: 오른쪽으로만 가는 경우, 왼쪽으로만 가는 경우, 오른쪽으로 가다가 왼쪽 유턴, 왼쪽으로 가다가 오른쪽 유턴
- 실패한 이유: 구현 시에 너무 조건이 많고 복잡해짐

## 🧐 문제 분류가 왜 탐욕법인가? (🤖)
- 초기에는 좌우 이동까지 탐욕법이 맞았음
- 근데, 테스트 케이스가 추가되면서 간단한 탐욕법으로 안 풀리고 완전 탐색에 탐욕법이 합쳐진 문제로 변함