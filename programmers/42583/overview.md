## 다리를 지나는 트럭
https://school.programmers.co.kr/learn/courses/30/lessons/42583

## 문제 이해
- 문제 설명만으로는 약간 애매모호함. 원본을 봐야 함
- 원본에 따르면, 하나의 단위시간에 하나의 단위길이만큼 이동한다고 되어 있음
    - -> 다리에 오른 트럭이 다리를 완전히 건널 때까지 bridge_length 초가 걸림
- 다리 위에 완전히 올라가지 못한 트럭 무게는 포함하지 않음
    - -> 다리의 끝에 조금이라도 트럭이 닿아있는 트럭의 무게도 미포함

## 전략 1: 시뮬레이션
- 다리를 시뮬레이션
    - 이때 다리는 큐로 활용함
    - 다만, 약간의 효율을 위해서 조건문 분기하여
        - 트럭이 올라갈 수 있는 경우, 트럭을 올리고 1초 증가
        - 트럭이 올라가지 못하는 경우, 시간을 다리의 맨 앞 트럭의 도착 시점으로 이동
- ⚠️ 주의할 점: 트럭이 내려가는 것의 처리에 유의해야 함 ⭐⭐⭐
    - 트럭이 내려가야 현재 무게 총합도, 현재 트럭 대수도 줄어듦
        - 이와 관련해서 실패하기 쉬운 테스트 케이스 (Q&A에서 찾음)
            - `bridge_length`: 5
            - `weight`: 5
            - `truck_weights`: [2, 2, 2, 2, 1, 1, 1, 1, 1]
            - 예상값: 19
        - 오답 풀이에서 계속 틀렸던 테스트 케이스로,
        - 트럭이 내려가는 것을 제대로 처리하지 못해서 현재 무게의 총합 계산이 꼬인 것이 원인이었음을 확인 
    - 제한 무게와 대수가 초과된 상황에서 새 트럭을 먼저 올리고 맨 앞 트럭이 내려가는 건 이치가 안 맞음
- ⚠️ 주의할 점 2: 다리 위에 완전히 올라가지 못한 트럭 무게는 포함하지 않음
    - -> t=3 시점에 완전히 도착하는 트럭이 있다면, t=2 초과 시점에서는 그 트럭의 무게는 포함되지 않게 됨

## 전략 2: 더미 트럭 이용 (🗒️)
- 다리를 시뮬레이션하는 아이디어는 같은데, 항상 다리를 더미 트럭 또는 실제 트럭으로 완전히 채워두는 방식
- 이 방식의 경우 마지막에 트럭 큐가 비었을 때 복잡하게 도착 시간을 계산하지 않고,
- 단순히 다리가 완전히 빌 때까지 pop하고 count하는 방식으로 처리할 수 있어서 로직이 직관적 -> 실수할 리스크 감소
- ⚠️ 바다코끼리 연산자의 우선 순위가 매우 낮으므로, 바다코끼리 연산자를 사용할 때는 괄호 처리를 잘 해줘야 함
    - 예: `if end_truck_weight := bridge.popleft() > 0:`는
        - `if (end_truck_weight := bridge.popleft()) > 0:`가 아니라
        - `if end_truck_weight := (bridge.popleft() > 0)`로 파싱됨 (비교 연산자 우선순위가 더 높음)